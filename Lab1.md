# 自旋锁
## 开关中断
为什么要在获取和释放锁的时候去开关中断？
	因为在xv6中，我们通过一个简单的方式来防止死锁，也就是在有锁锁上的时候就关闭所有的中断
但是这时候我们就遇到了一个问题，我们有可能同时启动了很多把锁，但是我们在释放一把锁的时候就可能直接把中断又开开了，这对别的中断是不公平的，所以我们需要维护一个特别的变量，来记录现在还持有多少锁，以便最后归零的时候再让中断恢复到原状态

我们为了实现开关中断，专门写了pushoff和popoff，它们会关注嵌套层数，来决定到底要不要开关中断

# uart
这个函数提供了几个接口，输出和读入单个字符，以及一个驱动启动函数，这个地方是一个小坑，我们要记得启动这个驱动，以前是在cosole里面的函数里启动的，我们要把它写在printinit里面
# print
提供了四种基础printf，以及panic和断言函数
需要注意的是printinit，我们要初始化专用的锁以及uart驱动
在每次printf开始的时候都要获取锁，最后完成后释放
# main
main函数里主要是执行printinit之后就可以开始后续操作了